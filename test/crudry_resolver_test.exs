defmodule CrudryResolverTest do
  use ExUnit.Case
  doctest Crudry.Resolver

  alias CrudryTest.Test
  alias Crudry.Repo

  defmodule Users do
    alias Crudry.User

    require Crudry.Context
    alias Crudry.Context

    Context.generate_functions(User)
  end

  defmodule Posts do
    alias Crudry.Post

    require Crudry.Context
    alias Crudry.Context

    Context.generate_functions(Post)
  end

  defmodule Context do
    alias CrudryTest.Repo
    alias CrudryTest.Test
    require Crudry.Context

    Crudry.Context.generate_functions(Test)
  end

  defmodule CamelizedContext do
    alias CrudryTest.Repo
    alias CrudryTest.CamelizedSchemaName
    require Crudry.Context

    Crudry.Context.generate_functions(CamelizedSchemaName)
  end

  @info %{}
  @userparams %{params: %{username: "test"}}

  test "creates the CRUD functions" do
    defmodule Resolver do
      Crudry.Resolver.generate_functions(Context, Test)
    end

    assert Resolver.get_test(%{id: 1}, @info) == {:ok, %Test{x: "123"}}
    assert Resolver.get_test(%{id: 0}, @info) == {:error, "Test not found."}
    assert Resolver.list_tests(%{}, @info) == {:ok, [1, 2, 3]}
    assert Resolver.create_test(%{params: %{x: 2}}, @info) == {:ok, %Test{x: 2}}
    assert Resolver.update_test(%{id: 3, params: %{x: 3}}, @info) == {:ok, %Test{x: 3}}
    assert Resolver.update_test(%{id: 0, params: %{x: 3}}, @info) == {:error, "Test not found."}
    assert Resolver.delete_test(%{id: 2}, @info) == {:ok, :deleted}
    assert Resolver.delete_test(%{id: 0}, @info) == {:error, "Test not found."}
  end

  test "choose which CRUD functions are to be generated" do
    defmodule ResolverOnly do
      Crudry.Resolver.generate_functions(Context, CrudryTest.Test, only: [:create, :list])
    end

    assert ResolverOnly.create_test(%{params: %{x: 2}}, @info) == {:ok, %Test{x: 2}}
    assert ResolverOnly.list_tests(%{}, @info) == {:ok, [1, 2, 3]}
    assert length(ResolverOnly.__info__(:functions)) == 3

    defmodule ResolverExcept do
      Crudry.Resolver.generate_functions(Context, CrudryTest.Test, except: [:list, :delete])
    end

    assert ResolverExcept.create_test(%{params: %{x: 2}}, @info) == {:ok, %Test{x: 2}}
    assert ResolverExcept.update_test(%{id: 3, params: %{x: 3}}, @info) == {:ok, %Test{x: 3}}
    assert length(ResolverExcept.__info__(:functions)) == 4
  end

  test "choose which CRUD functions are to be generated by default" do
    defmodule ResolverOnlyDefault do
      Crudry.Resolver.default(only: [:create, :list])
      Crudry.Resolver.generate_functions(Context, CrudryTest.Test)
    end

    assert ResolverOnlyDefault.create_test(%{params: %{x: 2}}, @info) == {:ok, %Test{x: 2}}
    assert ResolverOnlyDefault.list_tests(%{}, @info) == {:ok, [1, 2, 3]}
    assert length(ResolverOnlyDefault.__info__(:functions)) == 3

    defmodule ResolverExceptDefault do
      Crudry.Resolver.default(except: [:list, :delete])
      Crudry.Resolver.generate_functions(Context, CrudryTest.Test)
    end

    assert ResolverExceptDefault.create_test(%{params: %{x: 2}}, @info) == {:ok, %Test{x: 2}}

    assert ResolverExceptDefault.update_test(%{id: 3, params: %{x: 3}}, @info) ==
             {:ok, %Test{x: 3}}

    assert length(ResolverExceptDefault.__info__(:functions)) == 4
  end

  test "set default options for list" do
    :ok = Ecto.Adapters.SQL.Sandbox.checkout(Repo)

    defmodule ResolverListOptionsDefault do
      Crudry.Resolver.default list_opts: [order_by: :id, sorting_order: :desc]
      Crudry.Resolver.generate_functions(Users, User)
    end
    ResolverListOptionsDefault.create_user(@userparams, @info)
    ResolverListOptionsDefault.create_user(@userparams, @info)
    ResolverListOptionsDefault.create_user(@userparams, @info)
    ResolverListOptionsDefault.create_user(@userparams, @info)

    {:ok, user_list} = ResolverListOptionsDefault.list_users(%{}, @info)
    id_list = Enum.map(user_list, &(&1.id))
    assert List.first(id_list) > List.last(id_list)
  end

  test "set options for list" do
    :ok = Ecto.Adapters.SQL.Sandbox.checkout(Repo)

    defmodule ResolverListOptions do
      Crudry.Resolver.generate_functions(Users, User, list_opts: [order_by: :id, sorting_order: :asc])
      Crudry.Resolver.generate_functions(Posts, Post, list_opts: [order_by: [:user_id, :title]])
    end

    ResolverListOptions.create_user(@userparams, @info)
    ResolverListOptions.create_user(@userparams, @info)
    ResolverListOptions.create_user(@userparams, @info)
    ResolverListOptions.create_user(@userparams, @info)

    {:ok, user_list} = ResolverListOptions.list_users(%{}, @info)

    first_user_id = List.first(user_list) |> Map.get(:id)
    last_user_id = List.last(user_list) |> Map.get(:id)
    first_post_title = "Post A"
    last_post_title = "Post B"

    ResolverListOptions.create_post(%{params: %{user_id: last_user_id, title: last_post_title}}, @info)
    ResolverListOptions.create_post(%{params: %{user_id: last_user_id, title: first_post_title}}, @info)
    ResolverListOptions.create_post(%{params: %{user_id: first_user_id, title: last_post_title}}, @info)
    ResolverListOptions.create_post(%{params: %{user_id: first_user_id, title: first_post_title}}, @info)

    {:ok, post_list} = ResolverListOptions.list_posts(%{}, @info)

    id_list = Enum.map(user_list, &(&1.id))
    assert List.first(id_list) < List.last(id_list)
    assert [
      %{user_id: first_user_id, title: first_post_title},
      %{user_id: first_user_id, title: last_post_title},
      %{user_id: last_user_id, title: first_post_title},
      %{user_id: last_user_id, title: last_post_title}
    ] == Enum.map(post_list, & Map.take(&1, [:user_id, :title]))
  end

  test "create custom update using nil_to_error" do
    defmodule ResolverExceptUpdate do
      Crudry.Resolver.default(except: [:update])
      Crudry.Resolver.generate_functions(Context, CrudryTest.Test)

      def update_test(%{id: id, params: params}, _info) do
        Context.get_test(id)
        |> nil_to_error("test", fn record ->
          Context.update_test_with_assocs(record, params, [:assoc])
        end)
      end
    end

    assert ResolverExceptUpdate.update_test(%{id: 3, params: %{x: 3}}, @info) ==
             {:ok, %Test{x: 3, assocs: [:assoc]}}

    assert ResolverExceptUpdate.update_test(%{id: 0, params: %{x: 3}}, @info) ==
             {:error, "Test not found."}
  end

  test "Camelized name in error message" do
    defmodule CamelizedResolver do
      Crudry.Resolver.generate_functions(CamelizedContext, CrudryTest.CamelizedSchemaName)
    end

    assert CamelizedResolver.get_camelized_schema_name(%{id: 0}, @info) ==
             {:error, "CamelizedSchemaName not found."}
  end

  test "Generate only one nil_to_error function" do
    defmodule MultipleResolver do
      Crudry.Resolver.generate_functions(Context, Test)
      Crudry.Resolver.generate_functions(CamelizedContext, CrudryTest.CamelizedSchemaName)
    end

    # When multiplie nil_to_error functions are generated, a warning is raised.
    # Not sure how to test for warnings, so for now just let the test pass and check if there are no warnings manually.
    assert true
  end
end
